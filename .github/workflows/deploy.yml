name: Deploy to Cloud Run

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      services:
        description: 'Services to deploy (comma-separated, or "all")'
        required: false
        default: 'all'

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  REGISTRY: gcr.io
  REGION: us-central1

jobs:
  # Job 1: Determine deployment configuration
  setup:
    name: Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.config.outputs.environment }}
      services: ${{ steps.config.outputs.services }}
      deploy_tag: ${{ steps.config.outputs.deploy_tag }}
      should_migrate: ${{ steps.config.outputs.should_migrate }}
    
    steps:
      - name: Determine deployment configuration
        id: config
        run: |
          # Determine environment
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="staging"
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            ENVIRONMENT="production"
          else
            ENVIRONMENT="staging"
          fi
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          
          # Determine services to deploy
          if [[ "${{ github.event.inputs.services }}" == "" || "${{ github.event.inputs.services }}" == "all" ]]; then
            SERVICES="frontend,genui-orchestrator,user-context-service,kre-engine,streaming-adapter,pcm-classifier,ai-sommelier-service"
          else
            SERVICES="${{ github.event.inputs.services }}"
          fi
          echo "services=$SERVICES" >> $GITHUB_OUTPUT
          
          # Determine deployment tag
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            DEPLOY_TAG="${{ github.ref_name }}"
          else
            DEPLOY_TAG="main-${{ github.sha }}"
          fi
          echo "deploy_tag=$DEPLOY_TAG" >> $GITHUB_OUTPUT
          
          # Determine if we should run migrations
          if [[ "$ENVIRONMENT" == "production" && "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "should_migrate=true" >> $GITHUB_OUTPUT
          elif [[ "$ENVIRONMENT" == "staging" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "should_migrate=true" >> $GITHUB_OUTPUT
          else
            echo "should_migrate=false" >> $GITHUB_OUTPUT
          fi

  # Job 2: Database Migrations
  migrate:
    name: Database Migration
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_migrate == 'true'
    environment: ${{ needs.setup.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v1

      - name: Install Cloud SQL Proxy
        run: |
          curl -o cloud_sql_proxy https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64
          chmod +x cloud_sql_proxy
          sudo mv cloud_sql_proxy /usr/local/bin/

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Start Cloud SQL Proxy
        env:
          INSTANCE_CONNECTION_NAME: ${{ secrets.CLOUD_SQL_INSTANCE_CONNECTION_NAME }}
        run: |
          cloud_sql_proxy -instances=$INSTANCE_CONNECTION_NAME=tcp:5432 &
          sleep 10

      - name: Run Database Migrations
        env:
          DB_HOST: 127.0.0.1
          DB_PORT: 5432
          DB_NAME: ${{ secrets.DATABASE_NAME }}
          DB_USER: ${{ secrets.DATABASE_USER }}
          DB_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
        run: |
          chmod +x scripts/db/migrate.sh
          ./scripts/db/migrate.sh up

      - name: Verify Migration Status
        env:
          DB_HOST: 127.0.0.1
          DB_PORT: 5432
          DB_NAME: ${{ secrets.DATABASE_NAME }}
          DB_USER: ${{ secrets.DATABASE_USER }}
          DB_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
        run: |
          ./scripts/db/migrate.sh status

  # Job 3: Deploy Services to Cloud Run
  deploy:
    name: Deploy to Cloud Run
    runs-on: ubuntu-latest
    needs: [setup, migrate]
    if: always() && (needs.migrate.result == 'success' || needs.migrate.result == 'skipped')
    environment: ${{ needs.setup.outputs.environment }}
    
    strategy:
      matrix:
        service: ${{ fromJson(format('["{0}"]', join(split(needs.setup.outputs.services, ','), '","'))) }}
      fail-fast: false
      max-parallel: 3

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v1

      - name: Configure Docker for GCR
        run: gcloud auth configure-docker

      - name: Set service configuration
        id: service-config
        run: |
          case "${{ matrix.service }}" in
            "frontend")
              echo "port=3000" >> $GITHUB_OUTPUT
              echo "memory=1Gi" >> $GITHUB_OUTPUT
              echo "cpu=1" >> $GITHUB_OUTPUT
              echo "min_instances=1" >> $GITHUB_OUTPUT
              echo "max_instances=10" >> $GITHUB_OUTPUT
              echo "concurrency=100" >> $GITHUB_OUTPUT
              ;;
            "genui-orchestrator")
              echo "port=4000" >> $GITHUB_OUTPUT
              echo "memory=2Gi" >> $GITHUB_OUTPUT
              echo "cpu=2" >> $GITHUB_OUTPUT
              echo "min_instances=1" >> $GITHUB_OUTPUT
              echo "max_instances=20" >> $GITHUB_OUTPUT
              echo "concurrency=100" >> $GITHUB_OUTPUT
              ;;
            "kre-engine")
              echo "port=4001" >> $GITHUB_OUTPUT
              echo "memory=1Gi" >> $GITHUB_OUTPUT
              echo "cpu=1" >> $GITHUB_OUTPUT
              echo "min_instances=1" >> $GITHUB_OUTPUT
              echo "max_instances=15" >> $GITHUB_OUTPUT
              echo "concurrency=80" >> $GITHUB_OUTPUT
              ;;
            "user-context-service")
              echo "port=4002" >> $GITHUB_OUTPUT
              echo "memory=1Gi" >> $GITHUB_OUTPUT
              echo "cpu=1" >> $GITHUB_OUTPUT
              echo "min_instances=1" >> $GITHUB_OUTPUT
              echo "max_instances=15" >> $GITHUB_OUTPUT
              echo "concurrency=80" >> $GITHUB_OUTPUT
              ;;
            "pcm-classifier")
              echo "port=4003" >> $GITHUB_OUTPUT
              echo "memory=2Gi" >> $GITHUB_OUTPUT
              echo "cpu=2" >> $GITHUB_OUTPUT
              echo "min_instances=0" >> $GITHUB_OUTPUT
              echo "max_instances=10" >> $GITHUB_OUTPUT
              echo "concurrency=10" >> $GITHUB_OUTPUT
              ;;
            "ai-sommelier-service")
              echo "port=4004" >> $GITHUB_OUTPUT
              echo "memory=2Gi" >> $GITHUB_OUTPUT
              echo "cpu=2" >> $GITHUB_OUTPUT
              echo "min_instances=0" >> $GITHUB_OUTPUT
              echo "max_instances=10" >> $GITHUB_OUTPUT
              echo "concurrency=10" >> $GITHUB_OUTPUT
              ;;
            "streaming-adapter")
              echo "port=4005" >> $GITHUB_OUTPUT
              echo "memory=1Gi" >> $GITHUB_OUTPUT
              echo "cpu=1" >> $GITHUB_OUTPUT
              echo "min_instances=1" >> $GITHUB_OUTPUT
              echo "max_instances=5" >> $GITHUB_OUTPUT
              echo "concurrency=1000" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Deploy to Cloud Run
        run: |
          # Set environment-specific variables
          if [[ "${{ needs.setup.outputs.environment }}" == "production" ]]; then
            SERVICE_NAME="${{ matrix.service }}-prod"
            ENV_SUFFIX="-prod"
          else
            SERVICE_NAME="${{ matrix.service }}-staging"
            ENV_SUFFIX="-staging"
          fi
          
          # Deploy the service
          gcloud run deploy $SERVICE_NAME \
            --image=${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ matrix.service }}:${{ needs.setup.outputs.deploy_tag }} \
            --platform=managed \
            --region=${{ env.REGION }} \
            --allow-unauthenticated \
            --port=${{ steps.service-config.outputs.port }} \
            --memory=${{ steps.service-config.outputs.memory }} \
            --cpu=${{ steps.service-config.outputs.cpu }} \
            --min-instances=${{ steps.service-config.outputs.min_instances }} \
            --max-instances=${{ steps.service-config.outputs.max_instances }} \
            --concurrency=${{ steps.service-config.outputs.concurrency }} \
            --execution-environment=gen2 \
            --set-env-vars="ENV=${{ needs.setup.outputs.environment }}" \
            --set-env-vars="PORT=${{ steps.service-config.outputs.port }}" \
            --set-env-vars="DATABASE_URL=${{ secrets.DATABASE_URL }}$ENV_SUFFIX" \
            --set-env-vars="REDIS_URL=${{ secrets.REDIS_URL }}$ENV_SUFFIX" \
            --timeout=300 \
            --cpu-boost \
            --session-affinity

      - name: Set IAM Policy
        run: |
          if [[ "${{ needs.setup.outputs.environment }}" == "production" ]]; then
            SERVICE_NAME="${{ matrix.service }}-prod"
          else
            SERVICE_NAME="${{ matrix.service }}-staging"
          fi
          
          # Allow unauthenticated access for public services
          if [[ "${{ matrix.service }}" == "frontend" ]]; then
            gcloud run services add-iam-policy-binding $SERVICE_NAME \
              --region=${{ env.REGION }} \
              --member="allUsers" \
              --role="roles/run.invoker"
          fi

      - name: Get service URL
        id: url
        run: |
          if [[ "${{ needs.setup.outputs.environment }}" == "production" ]]; then
            SERVICE_NAME="${{ matrix.service }}-prod"
          else
            SERVICE_NAME="${{ matrix.service }}-staging"
          fi
          
          SERVICE_URL=$(gcloud run services describe $SERVICE_NAME \
            --region=${{ env.REGION }} \
            --format="value(status.url)")
          echo "url=$SERVICE_URL" >> $GITHUB_OUTPUT

      - name: Health Check
        run: |
          # Wait a bit for the service to be ready
          sleep 30
          
          # Perform health check
          HEALTH_URL="${{ steps.url.outputs.url }}/health"
          
          # Retry health check up to 5 times
          for i in {1..5}; do
            if curl -f -v -w "\nHTTP Status: %{http_code}\nTotal Time: %{time_total}s\n" "$HEALTH_URL" --connect-timeout 10 --max-time 30; then
              echo "Health check passed for ${{ matrix.service }}"
              exit 0
            else
              echo "Health check failed for ${{ matrix.service }}, attempt $i/5"
              sleep 15
            fi
          done
          
          echo "Health check failed after 5 attempts"
          exit 1

  # Job 4: Update Traffic Allocation
  traffic-split:
    name: Update Traffic Allocation
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    if: needs.setup.outputs.environment == 'production'
    environment: production

    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v1

      - name: Gradual Traffic Rollout
        run: |
          SERVICES="${{ needs.setup.outputs.services }}"
          IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
          
          for service in "${SERVICE_ARRAY[@]}"; do
            SERVICE_NAME="${service}-prod"
            
            echo "Starting gradual rollout for $SERVICE_NAME"
            
            # Step 1: 25% traffic to new revision
            echo "Routing 25% traffic to new revision..."
            gcloud run services update-traffic $SERVICE_NAME \
              --region=${{ env.REGION }} \
              --to-latest=25
            
            # Wait and monitor
            sleep 120
            
            # Step 2: 50% traffic to new revision
            echo "Routing 50% traffic to new revision..."
            gcloud run services update-traffic $SERVICE_NAME \
              --region=${{ env.REGION }} \
              --to-latest=50
            
            # Wait and monitor
            sleep 120
            
            # Step 3: 100% traffic to new revision
            echo "Routing 100% traffic to new revision..."
            gcloud run services update-traffic $SERVICE_NAME \
              --region=${{ env.REGION }} \
              --to-latest=100
            
            echo "Completed rollout for $SERVICE_NAME"
          done

  # Job 5: Smoke Tests
  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    if: always() && needs.deploy.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          npm install -g newman

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v1

      - name: Get service URLs
        id: urls
        run: |
          if [[ "${{ needs.setup.outputs.environment }}" == "production" ]]; then
            ENV_SUFFIX="-prod"
          else
            ENV_SUFFIX="-staging"
          fi
          
          FRONTEND_URL=$(gcloud run services describe frontend$ENV_SUFFIX \
            --region=${{ env.REGION }} --format="value(status.url)")
          API_URL=$(gcloud run services describe genui-orchestrator$ENV_SUFFIX \
            --region=${{ env.REGION }} --format="value(status.url)")
          
          echo "frontend_url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT

      - name: Run API Smoke Tests
        run: |
          # Basic API health checks
          echo "Testing API health endpoint..."
          curl -f -v -w "\nHTTP Status: %{http_code}\nTotal Time: %{time_total}s\n" "${{ steps.urls.outputs.api_url }}/health" || exit 1
          
          echo "Testing API metrics endpoint..."
          curl -f -v -w "\nHTTP Status: %{http_code}\nTotal Time: %{time_total}s\n" "${{ steps.urls.outputs.api_url }}/metrics" || exit 1
          
          # Run Postman collection if available
          if [ -f "tests/postman/smoke-tests.json" ]; then
            newman run tests/postman/smoke-tests.json \
              --env-var "base_url=${{ steps.urls.outputs.api_url }}"
          fi

      - name: Run Frontend Smoke Tests
        run: |
          # Basic frontend health check
          echo "Testing frontend availability..."
          curl -f "${{ steps.urls.outputs.frontend_url }}" || exit 1
          
          # Check critical pages
          curl -f "${{ steps.urls.outputs.frontend_url }}/login" || exit 1

  # Job 6: Notify Deployment Status
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [setup, deploy, smoke-tests, traffic-split]
    if: always()

    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" && "${{ needs.smoke-tests.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=✅ Deployment to ${{ needs.setup.outputs.environment }} completed successfully" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=❌ Deployment to ${{ needs.setup.outputs.environment }} failed" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "channel": "#deployments",
              "username": "GitHub Actions",
              "icon_emoji": ":rocket:",
              "text": "${{ steps.status.outputs.message }}",
              "attachments": [
                {
                  "color": "${{ steps.status.outputs.status == 'success' && 'good' || 'danger' }}",
                  "fields": [
                    {
                      "title": "Environment",
                      "value": "${{ needs.setup.outputs.environment }}",
                      "short": true
                    },
                    {
                      "title": "Services",
                      "value": "${{ needs.setup.outputs.services }}",
                      "short": true
                    },
                    {
                      "title": "Tag",
                      "value": "${{ needs.setup.outputs.deploy_tag }}",
                      "short": true
                    },
                    {
                      "title": "Commit",
                      "value": "<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>",
                      "short": true
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Job 7: Rollback on Failure
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [setup, deploy, smoke-tests]
    if: failure() && needs.setup.outputs.environment == 'production'
    environment: production

    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v1

      - name: Rollback to Previous Revision
        run: |
          SERVICES="${{ needs.setup.outputs.services }}"
          IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
          
          for service in "${SERVICE_ARRAY[@]}"; do
            SERVICE_NAME="${service}-prod"
            
            echo "Rolling back $SERVICE_NAME to previous revision..."
            
            # Get the previous revision
            PREVIOUS_REVISION=$(gcloud run revisions list \
              --service=$SERVICE_NAME \
              --region=${{ env.REGION }} \
              --limit=2 \
              --sort-by="~metadata.creationTimestamp" \
              --format="value(metadata.name)" | tail -1)
            
            if [[ -n "$PREVIOUS_REVISION" ]]; then
              # Route 100% traffic to previous revision
              gcloud run services update-traffic $SERVICE_NAME \
                --region=${{ env.REGION }} \
                --to-revisions=$PREVIOUS_REVISION=100
              
              echo "Rolled back $SERVICE_NAME to revision $PREVIOUS_REVISION"
            else
              echo "No previous revision found for $SERVICE_NAME"
            fi
          done

      - name: Notify Rollback
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "channel": "#deployments",
              "username": "GitHub Actions",
              "icon_emoji": ":warning:",
              "text": "🔄 Automatic rollback initiated for production deployment",
              "attachments": [
                {
                  "color": "warning",
                  "fields": [
                    {
                      "title": "Services Rolled Back",
                      "value": "${{ needs.setup.outputs.services }}",
                      "short": true
                    },
                    {
                      "title": "Reason",
                      "value": "Deployment or smoke tests failed",
                      "short": true
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}